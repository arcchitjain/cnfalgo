#include "WindowedRuleLearner.h"
#include "../exampletrie/ExampleTrie.h"
#include "../lib/SmartPointer.h"
#include "../language/RestrictedLanguage.h"
#include "../lib/profile.h" 
using namespace cnf;

WindowedRuleLearner::WindowedRuleLearner(int k, int w) : 
		RuleLearner(k), windowsize_(w) {
	setLanguage(*(new ExampleTrie()));
}

WindowedRuleLearner::~WindowedRuleLearner() {
	delete &getLanguage();
}

double WindowedRuleLearner::process_example(const std::vector<int>& example, int ex_id) {
	
	remove_example(ex_id - getWindowSize());
	
	return add_example(example, ex_id);
	
}

double WindowedRuleLearner::add_example(const std::vector<int>& example, int ex_id) {
	return RuleLearner::process_example(example,ex_id);
}

double WindowedRuleLearner::remove_example(int ex_id) {
	// removing an example requires rerunning the algorithm on the current window
	// for this we create another RuleLearner that has a restricted language
	// the rules generated by this RuleLearner must be subrules of the example that is removed

	// Read the example with the given index into example.
	std::vector<int> example;
	if (!getExamples().getExample(ex_id, example)) return 0;
	
	// Remove the example.
	getExamples().remove(ex_id);
	
	// Create a restricted language based on this example.
	RestrictedLanguage lang(example);
	
	// Create a new RuleLearner.
	RuleLearner cnf(getK());
	cnf.setLanguage(lang);
	cnf.setFilter(getFilter());
	cnf.initialize();
	
	//std::cout << "Removing example " << ex_id << " = " << str(example) << std::endl;
	// Reuse the example vector.
	example.clear();
	
	// Run the RuleLearner.
	for (int i=getExamples().getFirst(); i<=getExamples().getLast(); i++) {
		if (getExamples().getExample(i,example)) {
			//cout << "Rerunning for example " << i << endl;
			profile::start_timer(PROF_RERUN);
			profile::set_mode("Rerun");
			cnf.process_example(example,i);
			profile::reset_mode();
			profile::stop_timer(PROF_RERUN);
		} else {
			// Can happen if identical example occurs multiple times in 
			//	the window and the non-last one is requested.
			// TODO THIS GIVES PROBLEMS WHEN REMOVING EXAMPLES IN RANDOM ORDER !!!
			// print_warning("Requested a non existing example! ",str(i),__FILE__,__LINE__);
		}
		example.clear();
	}
	
	// Now the RuleLearner theory holds rules that failed on deleted example only.
	
	// merge cnf.getRules() with this.getRules()
	// Merging procedure:
	//	--> cnf.theory takes precedence over this.theory
	//	==> if a rule is true in cnf.theory then all superrules in this.theory
	//			must be pruned
	
	const TreeNode* rulenode = cnf.getRules().firstRule();
	
	while (rulenode) {
		std::vector<int> rule;
		rulenode->getRule(rule);
		
		//std::cout << "Pruning rule: " << str(rule) << endl;
		profile::start_timer(PROF_PRUNING);
		getRules().prune(&rule[0], static_cast<int>(rule.size()));
		profile::stop_timer(PROF_PRUNING);
		
		profile::start_timer(PROF_NEWADD);
		getRules().addRule(&rule[0], static_cast<int>(rule.size()),-ex_id-1);
		profile::stop_timer(PROF_NEWADD);
		
		rulenode = cnf.getRules().nextRule(&rule[0], static_cast<int>(rule.size()));	
	}	
			
	return 0;
}
